=pod

=head1 KUBJAS

Kubjas is periodic job scheduler that operates with minimum 1 second intervals.

Kubjas is not another cron daemon. Kubjas does not start programs at certain
time but at specified intervals. Kubjas also includes B<Time::Period> filter.
You can configure B<interval> and B<period> combinations that act like crontab.

Kubjas measures executed job running times and log it when job exits.
Measurements are in microseconds resolution.

Kubjas configuration is standard INI file format. You can have multiple
configuration files at same time. Main configuration is B</etc/kubjas.conf>
and B</etc/kubjas.d/> is for additional configurations. Each job can have
her own config file. You can force configuration reload with B<HUP> signal.

=over

=item example.conf

 [*]
 notify-failure = 192.168.1.27:catch-signals

 [date-job]
 cmdline = date +"%H:%M" > /var/tmp/date.txt
 run = periodic
 interval = 60
 user = nobody
 group = nogroup
 notify-success = 192.168.1.27:catch-signals

 [catch-signals]
 cmdline = /usr/local/bin/catch-signals.pl
 run = daemon
 interval = failure-message
 signal = USR2

 [readfile]
 cmdline = /usr/local/bin/readfile.sh
 interval = onchange
 watch = /var/tmp/date.txt
 user = nobody
 group = nogroup

 [very-shy-job]
 cmdline = /usr/local/bin/shy.sh
 interval = 10-20
 period = wd {1 3 5 7} min {0-29}, wd {2 4 6} min {30-59}
 depends = catch-signals
 conflicts = date-job
 nice = 1
 ionice = 1

=item job-name

[job-name] is the INI file section. Job names must be unique.

Special section name [*] sets default params that will be used
with all jobs. Named job sections overwrite default params.

=item cmdline

Parameter B<cmdline> define executable programm with parameters

 cmdline = perl /usr/local/bin/catch-signals.pl
 cmdline = catch-signals.pl

these lines are equivalent if PATH environment variable 
including /usr/local/bin and /usr/bin

Secure way is usage of full path names :-)

In combination with B<watch> and B<notify> you can add some template
parameters that will be filled with info at execution time.

 cmdline = send_alert.sh %host% %job% %notify%

Template name B<%host%> will replaced with hostname where notify origins.
Template name B<%job%> will replaced with job-name which sends the notify.
Template name B<%notify> will replaced with notify message which can be
B<start-message>, B<success-message>, B<failure-message> or B<filename>
that inotify B<watch> discovered B<IN_CLOSE_NOWRITE> event.

=item "run"

Allowable values are B<periodic> or B<daemon>. The main differences are
the way they are treated. Daemon jobs cannot print any output to STDOUT
or STDERR - the link between kubjas STDOUT and daemon is breaked.
Daemon jobs are started with kubjas and will be restarted any time they
exited. Kubjas will kill all daemon jobs at shutdown (restarts).

Periodic jobs STDOUT and STDERR output will be printed to kubjas logfile.
All running periodic jobs will run background until the end then kubjas
stops. Kubjas does not kill them.

=item interval

Specifies time in seconds between job last start. It is the minimum
delay between the different runs. Actual delay may be longer if other
conditions prevent running.

Interval can also be defined as randomized range. Example start job every
20 to 30 seconds.

 interval = 20-30 

There are also three special intervals that activated only by outside
events: B<onchange>, B<start-message>, B<success-message>, B<failure-message>

 interval = onchange
 interval = failure-message

onchange works with B<watch> parameter. see B<watch>

start-message, success-message, failure-message will trigger job
executing then notify message arrives. see B<notify-start>

=item period

Parameter determines if a given time falls within a given period.
Kubjas execute job only if period is met.

Period is optional param.

Theoretically you can emulate B<crontab> with B<interval> and B<period>
combination. Example job will be run only once a day at 0:00 midnight

 interval = 60
 period = hr {12am} min {0}

See also man B<Time::Period>. A sub-period is of the form

 scale {range [range ...]} [scale {range [range ...]}]

Scale must be one of nine different scales (or their equivalent codes):

 Scale  | Scale | Valid Range Values
        | Code  |
 ****************************************************************
 year   |  yr   | n     where n is an integer 0<=n<=99 or n>=1970
 month  |  mo   | 1-12  or  jan, feb, mar, apr, may, jun, jul,
        |       |           aug, sep, oct, nov, dec
 week   |  wk   | 1-6
 yday   |  yd   | 1-365
 mday   |  md   | 1-31
 wday   |  wd   | 1-7   or  su, mo, tu, we, th, fr, sa
 hour   |  hr   | 0-23  or  12am 1am-11am 12noon 12pm 1pm-11pm
 minute |  min  | 0-59
 second |  sec  | 0-59

crontab comparison [1]

 */5 * * * *  nobody  cmdline

 interval = 300
 user = nobody

crontab comparison [2]

 0 0 * * * 7  cmdline

 interval = 60
 period = wd {su} hr {12am} min {0}

or

 interval = 1
 period = wd {7} hr {0} min {0} sec {0}

crontab comparison [3]

 # run at 2:15pm on the first of every month
 15 14 1 * *  cmdline

 period = md {1} hr {14} min {15} sec {0}

crontab comparison [4]

 # run at 10 pm on weekdays
 0 22 * * 1-5  cmdline

 period = wd {Mon-Fri} hr {22} min {0} sec {0}

=item user

Run jobs as given user. Kubjas resolves user UID

=item group

Run jobs as given group. Kubjas resolves group GID.

=item watch

Kubjas is monitoring file system events with linux inotify API if
you specify list of files and directories to B<watch>.

One job can have many watch parameters. Kubjas monitors B<IN_CLOSE_NOWRITE>
events eg. change of file. Example:

 watch = /tmp

Will trigger job start always the /tmp direcotry changes. Only one
job at a time.

=item notify-start notify-success notify-failure

Kubjas will notify any other local or remote jobs then current job starts and
ends. Other job configuration specifies then it runs at B<start-message> or
B<success-message>. Example you can define two jobs that run after each other.

 [job-one]
 notify-success = 127.0.0.1:job-two
 interval = success-message

 [job-two]
 notify-success = 127.0.0.1:job-one
 interval = success-message

Then job exits with return code other than 0 (with some kind of failure) then
you can send failure notify to job that fix it or notifies administrator.

 [failure-handler]
 cmdline = /usr/local/bin/send_email_to_admin.sh
 interval = failure-message

=item conflicts

This job will only run if no specified jobs are running. Example you can
have CPU intensive jobs that runs only then other similar jobs not running.

 [hard-work]
 conflicts = cpu-work1
 conflicts = hard-work2

You can have multiple B<conflicts> params.

conflicts param can be special wildcard value that rule out any jobs
defined at the same configuration file.

 [spcial-job]
 conflicts = *

=item depends

This job will only run if depends are met. If specified jobs allready running.
Example you can run periodic jobs only if daemon job is running.

 depends = daemon-job
 depends = other-job

You can have multiple B<depends> params.

depends param can be special wildcard value that require all other jobs to
be running that are defined at the same configuration file.

 [ping]
 depends = *

=item nice ionice

Decrease executed job CPU and I/O scheduler priority.

 nice = 1
 ionice = 1

Will do "renice +10" and "ionice -c 3"

=item signal

Combined with B<interval> special cases you can send UNIX signals to running
jobs if notify event happen.

 [catch-signals]
 run = daemon
 interval = onchange
 watch = /tmp/date.txt
 signal = USR2

=back

=head1 AUTHOR

Kain Kalju <kain@kalju.com>

=head1 COPYRIGHT

Copyright (c) 2014 FlyCom OY (reg.code 10590327)
Ehitajate tee 108, Tallinn, Estonia
+372 680 6122
http://www.flycom.ee/

All rights reserved.

=head1 DATE

April 29, 2014

=cut
